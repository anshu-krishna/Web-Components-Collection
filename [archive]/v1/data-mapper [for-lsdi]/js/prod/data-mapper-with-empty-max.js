function is2DArray(val, rowSize = null) {
	if(!Array.isArray(val)) { return false; }
	for(const i of val) {
		if(!Array.isArray(i)) { return false; }
		if(rowSize !== null && i.length !== rowSize) {
			return false;
		}
	}
	return true;
};

function genNode(content, attr = {}) {
	const d = document.createElement('div');
	d.innerText = content;
	for(const [key, val] of Object.entries(attr)) {
		d.setAttribute(key, val);
	}
	return d.outerHTML;
}

/*******************************************************
 * format-funcs.js
*******************************************************/

const FormatFuncs = {
	switch: function(value, defaultV = null, ...pairs) {
		for(const p of pairs) {
			if(Array.isArray(p) && p.length === 2 && value === p[0]) {
				return p[1];
			}
		}
		return defaultV;
	},
	str: function(value) {
		return String(value);
	},
	'str.slice': function(value, start = 0, end = null) {
		if(typeof start === 'number') {
			if(typeof end === 'number') {
				return String(value).slice(start, end);
			} else {
				return String(value).slice(start);
			}
		}
		return null;
	},
	'str.part': function(value, start = 0, length = null) {
		if(typeof start === 'number') {
			if(typeof length === 'number') {
				return String(value).substring(start, start + length);
			} else {
				return String(value).substring(start);
			}
		}
		return null;
	},
	'str.trim': function(value) {
		return String(value).trim();
	},
	'str.trim.l': function(value) {
		return String(value).trimStart();
	},
	'str.trim.r': function(value) {
		return String(value).trimEnd();
	},
	'str.pad.l': function(value, maxLength, padWith = ' ') {
		return String(value).padStart(maxLength, padWith);
	},
	'str.pad.r': function(value, maxLength, padWith = ' ') {
		return String(value).padEnd(maxLength, padWith);
	},
	'str.upper': function(value) {
		return String(value).toUpperCase();
	},
	'str.lower': function(value) {
		return String(value).toLowerCase();
	},
	'str.title': function(value) {
		return String(value).replace(/\w\S*/g, txt => `${txt.charAt(0).toUpperCase()}${txt.slice(1).toLowerCase()}`);
	},
	'str.replace': function(value, search='', withStr='') {
		return String(value).replaceAll(search, withStr);
	},
	'str.at': function(value, index=0) {
		return String(value).at(index);
	},
	num: function(value) {
		return Number(value);
	},
	'num.add': function(value, secondNumber = 0) {
		return Number(value) + Number(secondNumber);
	},
	'num.sub': function(value, secondNumber = 0) {
		return Number(value) - Number(secondNumber);
	},
	'num.mul': function(value, secondNumber = 1) {
		return Number(value) * Number(secondNumber);
	},
	'num.div': function(value, secondNumber = 1) {
		secondNumber = Number(secondNumber);
		if(secondNumber !== 0) {
			return Number(value) / secondNumber;
		}
		return null;
	},
	'num.mod': function(value, secondNumber = 2) {
		secondNumber = Number(secondNumber);
		if(secondNumber !== 0) {
			return Number(value) % secondNumber;
		}
		return null;
	},
	'num.exp': function(value, secondNumber = 1) {
		return Number(value) ** Number(secondNumber);
	},
	'num.round': function(value, size = 2) {
		return Number(value).toFixed(Number(size));
	},
	"num.in_range": function(value, min = null, max = null) {
		value = Number(value);
		if(typeof min === 'number' && value < min) {
			return false;
		}
		if(typeof max === 'number' && value > max) {
			return false;
		}
		return true;
	},
	'bool': function(value) {
		return Boolean(value);
	}
};
const FuncList = Object.keys(FormatFuncs);

/*******************************************************
 * parser.js
*******************************************************/

const PEG = (function () {
	"use strict";
	/*
	* Generated by PEG.js 0.10.0. http://pegjs.org/
	* then updated/modified by Anshu Krishna <anshu.krishna5@gmail.com>
	*/

	function peg_subclass(child, parent) {
		function ctor() { this.constructor = child; }
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
	}

	function peg_SyntaxError(message, expected, found, location) {
		this.message = message;
		this.expected = expected;
		this.found = found;
		this.location = location;
		this.name = "SyntaxError";

		if (typeof Error.captureStackTrace === "function") {
			Error.captureStackTrace(this, peg_SyntaxError);
		}
	}

	peg_subclass(peg_SyntaxError, Error);

	peg_SyntaxError.buildMessage = function (expected, found) {
		let DESCRIBE_EXPECTATION_FNS = {
			literal: function (expectation) {
				return "\"" + literalEscape(expectation.text) + "\"";
			},

			"class": function (expectation) {
				let escapedParts = "",
					i;

				for (i = 0; i < expectation.parts.length; i++) {
					escapedParts += expectation.parts[i] instanceof Array
						? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
						: classEscape(expectation.parts[i]);
				}

				return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
			},

			any: function (expectation) {
				return "any character";
			},

			end: function (expectation) {
				return "end of input";
			},

			other: function (expectation) {
				return expectation.description;
			}
		};

		function hex(ch) {
			return ch.charCodeAt(0).toString(16).toUpperCase();
		}

		function literalEscape(s) {
			return s
				.replace(/\\/g, '\\\\')
				.replace(/"/g, '\\"')
				.replace(/\0/g, '\\0')
				.replace(/\t/g, '\\t')
				.replace(/\n/g, '\\n')
				.replace(/\r/g, '\\r')
				.replace(/[\x00-\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
				.replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return '\\x' + hex(ch); });
		}

		function classEscape(s) {
			return s
				.replace(/\\/g, '\\\\')
				.replace(/\]/g, '\\]')
				.replace(/\^/g, '\\^')
				.replace(/-/g, '\\-')
				.replace(/\0/g, '\\0')
				.replace(/\t/g, '\\t')
				.replace(/\n/g, '\\n')
				.replace(/\r/g, '\\r')
				.replace(/[\x00-\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
				.replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return '\\x' + hex(ch); });
		}

		function describeExpectation(expectation) {
			return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
		}

		function describeExpected(expected) {
			let descriptions = new Array(expected.length),
				i, j;

			for (i = 0; i < expected.length; i++) {
				descriptions[i] = describeExpectation(expected[i]);
			}

			descriptions.sort();

			if (descriptions.length > 0) {
				for (i = 1, j = 1; i < descriptions.length; i++) {
					if (descriptions[i - 1] !== descriptions[i]) {
						descriptions[j] = descriptions[i];
						j++;
					}
				}
				descriptions.length = j;
			}

			switch (descriptions.length) {
				case 1:
					return descriptions[0];

				case 2:
					return descriptions[0] + " or " + descriptions[1];

				default:
					return descriptions.slice(0, -1).join(", ")
						+ ", or "
						+ descriptions[descriptions.length - 1];
			}
		}

		function describeFound(found) {
			return found ? "\"" + literalEscape(found) + "\"" : "end of input";
		}

		return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
	};

	function peg_parse(input, options) {
		options = options !== void 0 ? options : {};

		let peg_FAILED = {},

			peg_startRuleFunctions = { Exp: peg_parseExp },
			peg_startRuleFunction = peg_parseExp,

			peg_c0 = peg_otherExpectation("Txt-Exp Chain"),
			peg_c1 = function (pre, cols) {
				let ret = [];
				if (pre !== "") {
					ret.push({ ty: "txt", val: pre });
				}
				for (const c of cols) {
					ret.push(c[0]);
					if (c[1] !== "") {
						ret.push({ ty: "txt", val: c[1] });
					}
				}
				return ret;
			},
			peg_c2 = peg_otherExpectation("Expression"),
			peg_c3 = "{",
			peg_c4 = peg_literalExpectation("{", false),
			peg_c5 = "}",
			peg_c6 = peg_literalExpectation("}", false),
			peg_c7 = function (col, maps, post) { return [{ ty: "exp", col: col, maps: maps }, post ?? ''] },
			peg_c8 = peg_otherExpectation("ColID"),
			peg_c9 = function () { return parseInt(text()); },
			peg_c10 = peg_otherExpectation("Function"),
			peg_c11 = "=>",
			peg_c12 = peg_literalExpectation("=>", false),
			peg_c13 = "(",
			peg_c14 = peg_literalExpectation("(", false),
			peg_c15 = function (func, head, v) { return v; },
			peg_c16 = function (func, head, tail) { return [head, ...tail]; },
			peg_c17 = ")",
			peg_c18 = peg_literalExpectation(")", false),
			peg_c19 = function (func, args) { return args ?? []; },
			peg_c20 = function (func, args) { return { func: func, args: args ?? [] }; },
			peg_c21 = peg_otherExpectation("Value"),
			peg_c22 = peg_otherExpectation("Null"),
			peg_c23 = "null",
			peg_c24 = peg_literalExpectation("null", false),
			peg_c25 = function () { return null; },
			peg_c26 = peg_otherExpectation("False"),
			peg_c27 = "false",
			peg_c28 = peg_literalExpectation("false", false),
			peg_c29 = function () { return false; },
			peg_c30 = peg_otherExpectation("True"),
			peg_c31 = "true",
			peg_c32 = peg_literalExpectation("true", false),
			peg_c33 = function () { return true; },
			peg_c34 = peg_otherExpectation("Object"),
			peg_c35 = function (head, m) { return m; },
			peg_c36 = function (head, tail) { return Object.fromEntries([head, ...tail]); },
			peg_c37 = function (prop) { return prop ?? {}; },
			peg_c38 = peg_otherExpectation("{Key:Value}"),
			peg_c39 = function (name, value) { return [name, value]; },
			peg_c40 = peg_otherExpectation("Key-Chain"),
			peg_c41 = ".",
			peg_c42 = peg_literalExpectation(".", false),
			peg_c43 = function () { return text(); },
			peg_c44 = peg_otherExpectation("Key"),
			peg_c45 = /^[_a-z$]/i,
			peg_c46 = peg_classExpectation(["_", ["a", "z"], "$"], false, true),
			peg_c47 = /^[0-9a-z$_]/i,
			peg_c48 = peg_classExpectation([["0", "9"], ["a", "z"], "$", "_"], false, true),
			peg_c49 = ":",
			peg_c50 = peg_literalExpectation(":", false),
			peg_c51 = peg_otherExpectation("Array"),
			peg_c52 = "[",
			peg_c53 = peg_literalExpectation("[", false),
			peg_c54 = function (head, v) { return v; },
			peg_c55 = function (head, tail) { return [head, ...tail]; },
			peg_c56 = "]",
			peg_c57 = peg_literalExpectation("]", false),
			peg_c58 = function (values) { return values ?? []; },
			peg_c59 = peg_otherExpectation("Number"),
			peg_c60 = "-",
			peg_c61 = peg_literalExpectation("-", false),
			peg_c62 = /^[eE]/,
			peg_c63 = peg_classExpectation(["e", "E"], false, false),
			peg_c64 = "+",
			peg_c65 = peg_literalExpectation("+", false),
			peg_c66 = function () { return parseFloat(text()); },
			peg_c67 = "0",
			peg_c68 = peg_literalExpectation("0", false),
			peg_c69 = /^[1-9]/,
			peg_c70 = peg_classExpectation([["1", "9"]], false, false),
			peg_c71 = peg_otherExpectation("String"),
			peg_c72 = "\"",
			peg_c73 = peg_literalExpectation("\"", false),
			peg_c74 = function (chars) { return chars.join(""); },
			peg_c75 = "'",
			peg_c76 = peg_literalExpectation("'", false),
			peg_c77 = "`",
			peg_c78 = peg_literalExpectation("`", false),
			peg_c79 = /^[^\0-\x1F\\"]/,
			peg_c80 = peg_classExpectation([["\0", "\x1F"], "\\", "\""], true, false),
			peg_c81 = function (esc) { return esc; },
			peg_c82 = /^[^\0-\x1F\\']/,
			peg_c83 = peg_classExpectation([["\0", "\x1F"], "\\", "'"], true, false),
			peg_c84 = /^[^\0-\x1F\\`]/,
			peg_c85 = peg_classExpectation([["\0", "\x1F"], "\\", "`"], true, false),
			peg_c86 = peg_otherExpectation("Escaped-Char"),
			peg_c87 = "\\\\",
			peg_c88 = peg_literalExpectation("\\\\", false),
			peg_c89 = function () { return '\\'; },
			peg_c90 = "\\\"",
			peg_c91 = peg_literalExpectation("\\\"", false),
			peg_c92 = function () { return '"'; },
			peg_c93 = "\\'",
			peg_c94 = peg_literalExpectation("\\'", false),
			peg_c95 = function () { return "'"; },
			peg_c96 = "\\`",
			peg_c97 = peg_literalExpectation("\\`", false),
			peg_c98 = function () { return "`"; },
			peg_c99 = "\\b",
			peg_c100 = peg_literalExpectation("\\b", false),
			peg_c101 = function () { return "\b"; },
			peg_c102 = "\\f",
			peg_c103 = peg_literalExpectation("\\f", false),
			peg_c104 = function () { return "\f"; },
			peg_c105 = "\\n",
			peg_c106 = peg_literalExpectation("\\n", false),
			peg_c107 = function () { return "\n"; },
			peg_c108 = "\\r",
			peg_c109 = peg_literalExpectation("\\r", false),
			peg_c110 = function () { return "\r"; },
			peg_c111 = "\\t",
			peg_c112 = peg_literalExpectation("\\t", false),
			peg_c113 = function () { return "\t"; },
			peg_c114 = "\\u",
			peg_c115 = peg_literalExpectation("\\u", false),
			peg_c116 = function (digits) { return String.fromCharCode(parseInt(digits, 16)); },
			peg_c117 = peg_otherExpectation("Text"),
			peg_c118 = /^[^\\{]/,
			peg_c119 = peg_classExpectation(["\\", "{"], true, false),
			peg_c120 = "\\{",
			peg_c121 = peg_literalExpectation("\\{", false),
			peg_c122 = function () { return "\x7B"; },
			peg_c123 = function (txt) { return txt.join(""); },
			peg_c124 = peg_otherExpectation("Digit[0-9]"),
			peg_c125 = /^[0-9]/,
			peg_c126 = peg_classExpectation([["0", "9"]], false, false),
			peg_c127 = ",",
			peg_c128 = peg_literalExpectation(",", false),
			peg_c129 = peg_otherExpectation("Whitespace"),
			peg_c130 = /^[ \t\n\r]/,
			peg_c131 = peg_classExpectation([" ", "\t", "\n", "\r"], false, false),
			peg_c132 = /^[0-9a-f]/i,
			peg_c133 = peg_classExpectation([["0", "9"], ["a", "f"]], false, true),

			peg_currPos = 0,
			peg_savedPos = 0,
			peg_posDetailsCache = [{ line: 1, column: 1 }],
			peg_maxFailPos = 0,
			peg_maxFailExpected = [],
			peg_silentFails = 0,

			peg_result;

		if ("startRule" in options) {
			if (!(options.startRule in peg_startRuleFunctions)) {
				throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
			}

			peg_startRuleFunction = peg_startRuleFunctions[options.startRule];
		}

		function text() {
			return input.substring(peg_savedPos, peg_currPos);
		}

		function location() {
			return peg_computeLocation(peg_savedPos, peg_currPos);
		}

		function expected(description, location) {
			location = location !== void 0 ? location : peg_computeLocation(peg_savedPos, peg_currPos)

			throw peg_buildStructuredError(
				[peg_otherExpectation(description)],
				input.substring(peg_savedPos, peg_currPos),
				location
			);
		}

		function error(message, location) {
			location = location !== void 0 ? location : peg_computeLocation(peg_savedPos, peg_currPos)

			throw peg_buildSimpleError(message, location);
		}

		function peg_literalExpectation(text, ignoreCase) {
			return { type: "literal", text: text, ignoreCase: ignoreCase };
		}

		function peg_classExpectation(parts, inverted, ignoreCase) {
			return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
		}

		function peg_anyExpectation() {
			return { type: "any" };
		}

		function peg_endExpectation() {
			return { type: "end" };
		}

		function peg_otherExpectation(description) {
			return { type: "other", description: description };
		}

		function peg_computePosDetails(pos) {
			let details = peg_posDetailsCache[pos], p;

			if (details) {
				return details;
			} else {
				p = pos - 1;
				while (!peg_posDetailsCache[p]) {
					p--;
				}

				details = peg_posDetailsCache[p];
				details = {
					line: details.line,
					column: details.column
				};

				while (p < pos) {
					if (input.charCodeAt(p) === 10) {
						details.line++;
						details.column = 1;
					} else {
						details.column++;
					}

					p++;
				}

				peg_posDetailsCache[pos] = details;
				return details;
			}
		}

		function peg_computeLocation(startPos, endPos) {
			let startPosDetails = peg_computePosDetails(startPos),
				endPosDetails = peg_computePosDetails(endPos);

			return {
				start: {
					offset: startPos,
					line: startPosDetails.line,
					column: startPosDetails.column
				},
				end: {
					offset: endPos,
					line: endPosDetails.line,
					column: endPosDetails.column
				}
			};
		}

		function peg_fail(expected) {
			if (peg_currPos < peg_maxFailPos) { return; }

			if (peg_currPos > peg_maxFailPos) {
				peg_maxFailPos = peg_currPos;
				peg_maxFailExpected = [];
			}

			peg_maxFailExpected.push(expected);
		}

		function peg_buildSimpleError(message, location) {
			return new peg_SyntaxError(message, null, null, location);
		}

		function peg_buildStructuredError(expected, found, location) {
			return new peg_SyntaxError(
				peg_SyntaxError.buildMessage(expected, found),
				expected,
				found,
				location
			);
		}

		function peg_parseExp() {
			let s0, s1, s2, s3;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parseTxt();
			if (s1 === peg_FAILED) {
				s1 = null;
			}
			if (s1 !== peg_FAILED) {
				s2 = [];
				s3 = peg_parseOneExp();
				while (s3 !== peg_FAILED) {
					s2.push(s3);
					s3 = peg_parseOneExp();
				}
				if (s2 !== peg_FAILED) {
					peg_savedPos = s0;
					s1 = peg_c1(s1, s2);
					s0 = s1;
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c0); }
			}

			return s0;
		}

		function peg_parseOneExp() {
			let s0, s1, s2, s3, s4, s5, s6, s7, s8;

			peg_silentFails++;
			s0 = peg_currPos;
			if (input.charCodeAt(peg_currPos) === 123) {
				s1 = peg_c3;
				peg_currPos++;
			} else {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c4); }
			}
			if (s1 !== peg_FAILED) {
				s2 = peg_parse_();
				if (s2 !== peg_FAILED) {
					s3 = peg_parseColID();
					if (s3 !== peg_FAILED) {
						s4 = peg_parse_();
						if (s4 !== peg_FAILED) {
							s5 = [];
							s6 = peg_parseFunc();
							while (s6 !== peg_FAILED) {
								s5.push(s6);
								s6 = peg_parseFunc();
							}
							if (s5 !== peg_FAILED) {
								s6 = peg_parse_();
								if (s6 !== peg_FAILED) {
									if (input.charCodeAt(peg_currPos) === 125) {
										s7 = peg_c5;
										peg_currPos++;
									} else {
										s7 = peg_FAILED;
										if (peg_silentFails === 0) { peg_fail(peg_c6); }
									}
									if (s7 !== peg_FAILED) {
										s8 = peg_parseTxt();
										if (s8 === peg_FAILED) {
											s8 = null;
										}
										if (s8 !== peg_FAILED) {
											peg_savedPos = s0;
											s1 = peg_c7(s3, s5, s8);
											s0 = s1;
										} else {
											peg_currPos = s0;
											s0 = peg_FAILED;
										}
									} else {
										peg_currPos = s0;
										s0 = peg_FAILED;
									}
								} else {
									peg_currPos = s0;
									s0 = peg_FAILED;
								}
							} else {
								peg_currPos = s0;
								s0 = peg_FAILED;
							}
						} else {
							peg_currPos = s0;
							s0 = peg_FAILED;
						}
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c2); }
			}

			return s0;
		}

		function peg_parseColID() {
			let s0, s1;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parseSimpleInt();
			if (s1 !== peg_FAILED) {
				peg_savedPos = s0;
				s1 = peg_c9();
			}
			s0 = s1;
			if (s0 === peg_FAILED) {
				s0 = peg_parseString();
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c8); }
			}

			return s0;
		}

		function peg_parseFunc() {
			let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parse_();
			if (s1 !== peg_FAILED) {
				if (input.substr(peg_currPos, 2) === peg_c11) {
					s2 = peg_c11;
					peg_currPos += 2;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c12); }
				}
				if (s2 !== peg_FAILED) {
					s3 = peg_parse_();
					if (s3 !== peg_FAILED) {
						s4 = peg_parseKeyChain();
						if (s4 !== peg_FAILED) {
							s5 = peg_currPos;
							s6 = peg_parse_();
							if (s6 !== peg_FAILED) {
								if (input.charCodeAt(peg_currPos) === 40) {
									s7 = peg_c13;
									peg_currPos++;
								} else {
									s7 = peg_FAILED;
									if (peg_silentFails === 0) { peg_fail(peg_c14); }
								}
								if (s7 !== peg_FAILED) {
									s8 = peg_parse_();
									if (s8 !== peg_FAILED) {
										s9 = peg_currPos;
										s10 = peg_parseValue();
										if (s10 !== peg_FAILED) {
											s11 = [];
											s12 = peg_currPos;
											s13 = peg_parseComma();
											if (s13 !== peg_FAILED) {
												s14 = peg_parseValue();
												if (s14 !== peg_FAILED) {
													peg_savedPos = s12;
													s13 = peg_c15(s4, s10, s14);
													s12 = s13;
												} else {
													peg_currPos = s12;
													s12 = peg_FAILED;
												}
											} else {
												peg_currPos = s12;
												s12 = peg_FAILED;
											}
											while (s12 !== peg_FAILED) {
												s11.push(s12);
												s12 = peg_currPos;
												s13 = peg_parseComma();
												if (s13 !== peg_FAILED) {
													s14 = peg_parseValue();
													if (s14 !== peg_FAILED) {
														peg_savedPos = s12;
														s13 = peg_c15(s4, s10, s14);
														s12 = s13;
													} else {
														peg_currPos = s12;
														s12 = peg_FAILED;
													}
												} else {
													peg_currPos = s12;
													s12 = peg_FAILED;
												}
											}
											if (s11 !== peg_FAILED) {
												s12 = peg_parseComma();
												if (s12 === peg_FAILED) {
													s12 = null;
												}
												if (s12 !== peg_FAILED) {
													peg_savedPos = s9;
													s10 = peg_c16(s4, s10, s11);
													s9 = s10;
												} else {
													peg_currPos = s9;
													s9 = peg_FAILED;
												}
											} else {
												peg_currPos = s9;
												s9 = peg_FAILED;
											}
										} else {
											peg_currPos = s9;
											s9 = peg_FAILED;
										}
										if (s9 === peg_FAILED) {
											s9 = null;
										}
										if (s9 !== peg_FAILED) {
											s10 = peg_parse_();
											if (s10 !== peg_FAILED) {
												if (input.charCodeAt(peg_currPos) === 41) {
													s11 = peg_c17;
													peg_currPos++;
												} else {
													s11 = peg_FAILED;
													if (peg_silentFails === 0) { peg_fail(peg_c18); }
												}
												if (s11 !== peg_FAILED) {
													s12 = peg_parse_();
													if (s12 !== peg_FAILED) {
														peg_savedPos = s5;
														s6 = peg_c19(s4, s9);
														s5 = s6;
													} else {
														peg_currPos = s5;
														s5 = peg_FAILED;
													}
												} else {
													peg_currPos = s5;
													s5 = peg_FAILED;
												}
											} else {
												peg_currPos = s5;
												s5 = peg_FAILED;
											}
										} else {
											peg_currPos = s5;
											s5 = peg_FAILED;
										}
									} else {
										peg_currPos = s5;
										s5 = peg_FAILED;
									}
								} else {
									peg_currPos = s5;
									s5 = peg_FAILED;
								}
							} else {
								peg_currPos = s5;
								s5 = peg_FAILED;
							}
							if (s5 === peg_FAILED) {
								s5 = null;
							}
							if (s5 !== peg_FAILED) {
								peg_savedPos = s0;
								s1 = peg_c20(s4, s5);
								s0 = s1;
							} else {
								peg_currPos = s0;
								s0 = peg_FAILED;
							}
						} else {
							peg_currPos = s0;
							s0 = peg_FAILED;
						}
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c10); }
			}

			return s0;
		}

		function peg_parseValue() {
			let s0, s1;

			peg_silentFails++;
			s0 = peg_parseFalse();
			if (s0 === peg_FAILED) {
				s0 = peg_parseNull();
				if (s0 === peg_FAILED) {
					s0 = peg_parseTrue();
					if (s0 === peg_FAILED) {
						s0 = peg_parseObject();
						if (s0 === peg_FAILED) {
							s0 = peg_parseArray();
							if (s0 === peg_FAILED) {
								s0 = peg_parseNumber();
								if (s0 === peg_FAILED) {
									s0 = peg_parseString();
								}
							}
						}
					}
				}
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c21); }
			}

			return s0;
		}

		function peg_parseNull() {
			let s0, s1, s2, s3;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parse_();
			if (s1 !== peg_FAILED) {
				if (input.substr(peg_currPos, 4) === peg_c23) {
					s2 = peg_c23;
					peg_currPos += 4;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c24); }
				}
				if (s2 !== peg_FAILED) {
					s3 = peg_parse_();
					if (s3 !== peg_FAILED) {
						peg_savedPos = s0;
						s1 = peg_c25();
						s0 = s1;
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c22); }
			}

			return s0;
		}

		function peg_parseFalse() {
			let s0, s1, s2, s3;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parse_();
			if (s1 !== peg_FAILED) {
				if (input.substr(peg_currPos, 5) === peg_c27) {
					s2 = peg_c27;
					peg_currPos += 5;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c28); }
				}
				if (s2 !== peg_FAILED) {
					s3 = peg_parse_();
					if (s3 !== peg_FAILED) {
						peg_savedPos = s0;
						s1 = peg_c29();
						s0 = s1;
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c26); }
			}

			return s0;
		}

		function peg_parseTrue() {
			let s0, s1, s2, s3;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parse_();
			if (s1 !== peg_FAILED) {
				if (input.substr(peg_currPos, 4) === peg_c31) {
					s2 = peg_c31;
					peg_currPos += 4;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c32); }
				}
				if (s2 !== peg_FAILED) {
					s3 = peg_parse_();
					if (s3 !== peg_FAILED) {
						peg_savedPos = s0;
						s1 = peg_c33();
						s0 = s1;
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c30); }
			}

			return s0;
		}

		function peg_parseObject() {
			let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parse_();
			if (s1 !== peg_FAILED) {
				if (input.charCodeAt(peg_currPos) === 123) {
					s2 = peg_c3;
					peg_currPos++;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c4); }
				}
				if (s2 !== peg_FAILED) {
					s3 = peg_parse_();
					if (s3 !== peg_FAILED) {
						s4 = peg_currPos;
						s5 = peg_parseKeyVal();
						if (s5 !== peg_FAILED) {
							s6 = [];
							s7 = peg_currPos;
							s8 = peg_parseComma();
							if (s8 !== peg_FAILED) {
								s9 = peg_parseKeyVal();
								if (s9 !== peg_FAILED) {
									peg_savedPos = s7;
									s8 = peg_c35(s5, s9);
									s7 = s8;
								} else {
									peg_currPos = s7;
									s7 = peg_FAILED;
								}
							} else {
								peg_currPos = s7;
								s7 = peg_FAILED;
							}
							while (s7 !== peg_FAILED) {
								s6.push(s7);
								s7 = peg_currPos;
								s8 = peg_parseComma();
								if (s8 !== peg_FAILED) {
									s9 = peg_parseKeyVal();
									if (s9 !== peg_FAILED) {
										peg_savedPos = s7;
										s8 = peg_c35(s5, s9);
										s7 = s8;
									} else {
										peg_currPos = s7;
										s7 = peg_FAILED;
									}
								} else {
									peg_currPos = s7;
									s7 = peg_FAILED;
								}
							}
							if (s6 !== peg_FAILED) {
								peg_savedPos = s4;
								s5 = peg_c36(s5, s6);
								s4 = s5;
							} else {
								peg_currPos = s4;
								s4 = peg_FAILED;
							}
						} else {
							peg_currPos = s4;
							s4 = peg_FAILED;
						}
						if (s4 === peg_FAILED) {
							s4 = null;
						}
						if (s4 !== peg_FAILED) {
							s5 = peg_parseComma();
							if (s5 === peg_FAILED) {
								s5 = null;
							}
							if (s5 !== peg_FAILED) {
								s6 = peg_parse_();
								if (s6 !== peg_FAILED) {
									if (input.charCodeAt(peg_currPos) === 125) {
										s7 = peg_c5;
										peg_currPos++;
									} else {
										s7 = peg_FAILED;
										if (peg_silentFails === 0) { peg_fail(peg_c6); }
									}
									if (s7 !== peg_FAILED) {
										s8 = peg_parse_();
										if (s8 !== peg_FAILED) {
											peg_savedPos = s0;
											s1 = peg_c37(s4);
											s0 = s1;
										} else {
											peg_currPos = s0;
											s0 = peg_FAILED;
										}
									} else {
										peg_currPos = s0;
										s0 = peg_FAILED;
									}
								} else {
									peg_currPos = s0;
									s0 = peg_FAILED;
								}
							} else {
								peg_currPos = s0;
								s0 = peg_FAILED;
							}
						} else {
							peg_currPos = s0;
							s0 = peg_FAILED;
						}
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c34); }
			}

			return s0;
		}

		function peg_parseKeyVal() {
			let s0, s1, s2, s3;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parseString();
			if (s1 === peg_FAILED) {
				s1 = peg_parseKeyChain();
			}
			if (s1 !== peg_FAILED) {
				s2 = peg_parseColon();
				if (s2 !== peg_FAILED) {
					s3 = peg_parseValue();
					if (s3 !== peg_FAILED) {
						peg_savedPos = s0;
						s1 = peg_c39(s1, s3);
						s0 = s1;
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c38); }
			}

			return s0;
		}

		function peg_parseKeyChain() {
			let s0, s1, s2, s3, s4, s5;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parseKey();
			if (s1 !== peg_FAILED) {
				s2 = [];
				s3 = peg_currPos;
				if (input.charCodeAt(peg_currPos) === 46) {
					s4 = peg_c41;
					peg_currPos++;
				} else {
					s4 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c42); }
				}
				if (s4 !== peg_FAILED) {
					s5 = peg_parseKey();
					if (s5 !== peg_FAILED) {
						s4 = [s4, s5];
						s3 = s4;
					} else {
						peg_currPos = s3;
						s3 = peg_FAILED;
					}
				} else {
					peg_currPos = s3;
					s3 = peg_FAILED;
				}
				while (s3 !== peg_FAILED) {
					s2.push(s3);
					s3 = peg_currPos;
					if (input.charCodeAt(peg_currPos) === 46) {
						s4 = peg_c41;
						peg_currPos++;
					} else {
						s4 = peg_FAILED;
						if (peg_silentFails === 0) { peg_fail(peg_c42); }
					}
					if (s4 !== peg_FAILED) {
						s5 = peg_parseKey();
						if (s5 !== peg_FAILED) {
							s4 = [s4, s5];
							s3 = s4;
						} else {
							peg_currPos = s3;
							s3 = peg_FAILED;
						}
					} else {
						peg_currPos = s3;
						s3 = peg_FAILED;
					}
				}
				if (s2 !== peg_FAILED) {
					peg_savedPos = s0;
					s1 = peg_c43();
					s0 = s1;
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c40); }
			}

			return s0;
		}

		function peg_parseKey() {
			let s0, s1, s2, s3, s4;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_currPos;
			if (peg_c45.test(input.charAt(peg_currPos))) {
				s2 = input.charAt(peg_currPos);
				peg_currPos++;
			} else {
				s2 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c46); }
			}
			if (s2 !== peg_FAILED) {
				s3 = [];
				if (peg_c47.test(input.charAt(peg_currPos))) {
					s4 = input.charAt(peg_currPos);
					peg_currPos++;
				} else {
					s4 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c48); }
				}
				while (s4 !== peg_FAILED) {
					s3.push(s4);
					if (peg_c47.test(input.charAt(peg_currPos))) {
						s4 = input.charAt(peg_currPos);
						peg_currPos++;
					} else {
						s4 = peg_FAILED;
						if (peg_silentFails === 0) { peg_fail(peg_c48); }
					}
				}
				if (s3 !== peg_FAILED) {
					s2 = [s2, s3];
					s1 = s2;
				} else {
					peg_currPos = s1;
					s1 = peg_FAILED;
				}
			} else {
				peg_currPos = s1;
				s1 = peg_FAILED;
			}
			if (s1 !== peg_FAILED) {
				peg_savedPos = s0;
				s1 = peg_c43();
			}
			s0 = s1;
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c44); }
			}

			return s0;
		}

		function peg_parseColon() {
			let s0, s1, s2, s3;

			s0 = peg_currPos;
			s1 = peg_parse_();
			if (s1 !== peg_FAILED) {
				if (input.charCodeAt(peg_currPos) === 58) {
					s2 = peg_c49;
					peg_currPos++;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c50); }
				}
				if (s2 !== peg_FAILED) {
					s3 = peg_parse_();
					if (s3 !== peg_FAILED) {
						s1 = [s1, s2, s3];
						s0 = s1;
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}

			return s0;
		}

		function peg_parseArray() {
			let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = peg_parse_();
			if (s1 !== peg_FAILED) {
				if (input.charCodeAt(peg_currPos) === 91) {
					s2 = peg_c52;
					peg_currPos++;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c53); }
				}
				if (s2 !== peg_FAILED) {
					s3 = peg_parse_();
					if (s3 !== peg_FAILED) {
						s4 = peg_currPos;
						s5 = peg_parseValue();
						if (s5 !== peg_FAILED) {
							s6 = [];
							s7 = peg_currPos;
							s8 = peg_parseComma();
							if (s8 !== peg_FAILED) {
								s9 = peg_parseValue();
								if (s9 !== peg_FAILED) {
									peg_savedPos = s7;
									s8 = peg_c54(s5, s9);
									s7 = s8;
								} else {
									peg_currPos = s7;
									s7 = peg_FAILED;
								}
							} else {
								peg_currPos = s7;
								s7 = peg_FAILED;
							}
							while (s7 !== peg_FAILED) {
								s6.push(s7);
								s7 = peg_currPos;
								s8 = peg_parseComma();
								if (s8 !== peg_FAILED) {
									s9 = peg_parseValue();
									if (s9 !== peg_FAILED) {
										peg_savedPos = s7;
										s8 = peg_c54(s5, s9);
										s7 = s8;
									} else {
										peg_currPos = s7;
										s7 = peg_FAILED;
									}
								} else {
									peg_currPos = s7;
									s7 = peg_FAILED;
								}
							}
							if (s6 !== peg_FAILED) {
								peg_savedPos = s4;
								s5 = peg_c55(s5, s6);
								s4 = s5;
							} else {
								peg_currPos = s4;
								s4 = peg_FAILED;
							}
						} else {
							peg_currPos = s4;
							s4 = peg_FAILED;
						}
						if (s4 === peg_FAILED) {
							s4 = null;
						}
						if (s4 !== peg_FAILED) {
							s5 = peg_parseComma();
							if (s5 === peg_FAILED) {
								s5 = null;
							}
							if (s5 !== peg_FAILED) {
								s6 = peg_parse_();
								if (s6 !== peg_FAILED) {
									if (input.charCodeAt(peg_currPos) === 93) {
										s7 = peg_c56;
										peg_currPos++;
									} else {
										s7 = peg_FAILED;
										if (peg_silentFails === 0) { peg_fail(peg_c57); }
									}
									if (s7 !== peg_FAILED) {
										s8 = peg_parse_();
										if (s8 !== peg_FAILED) {
											peg_savedPos = s0;
											s1 = peg_c58(s4);
											s0 = s1;
										} else {
											peg_currPos = s0;
											s0 = peg_FAILED;
										}
									} else {
										peg_currPos = s0;
										s0 = peg_FAILED;
									}
								} else {
									peg_currPos = s0;
									s0 = peg_FAILED;
								}
							} else {
								peg_currPos = s0;
								s0 = peg_FAILED;
							}
						} else {
							peg_currPos = s0;
							s0 = peg_FAILED;
						}
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c51); }
			}

			return s0;
		}

		function peg_parseNumber() {
			let s0, s1, s2, s3, s4, s5, s6, s7, s8;

			peg_silentFails++;
			s0 = peg_currPos;
			if (input.charCodeAt(peg_currPos) === 45) {
				s1 = peg_c60;
				peg_currPos++;
			} else {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c61); }
			}
			if (s1 === peg_FAILED) {
				s1 = null;
			}
			if (s1 !== peg_FAILED) {
				s2 = peg_parseSimpleInt();
				if (s2 !== peg_FAILED) {
					s3 = peg_currPos;
					if (input.charCodeAt(peg_currPos) === 46) {
						s4 = peg_c41;
						peg_currPos++;
					} else {
						s4 = peg_FAILED;
						if (peg_silentFails === 0) { peg_fail(peg_c42); }
					}
					if (s4 !== peg_FAILED) {
						s5 = [];
						s6 = peg_parseDigit();
						if (s6 !== peg_FAILED) {
							while (s6 !== peg_FAILED) {
								s5.push(s6);
								s6 = peg_parseDigit();
							}
						} else {
							s5 = peg_FAILED;
						}
						if (s5 !== peg_FAILED) {
							s4 = [s4, s5];
							s3 = s4;
						} else {
							peg_currPos = s3;
							s3 = peg_FAILED;
						}
					} else {
						peg_currPos = s3;
						s3 = peg_FAILED;
					}
					if (s3 === peg_FAILED) {
						s3 = null;
					}
					if (s3 !== peg_FAILED) {
						s4 = peg_currPos;
						if (peg_c62.test(input.charAt(peg_currPos))) {
							s5 = input.charAt(peg_currPos);
							peg_currPos++;
						} else {
							s5 = peg_FAILED;
							if (peg_silentFails === 0) { peg_fail(peg_c63); }
						}
						if (s5 !== peg_FAILED) {
							if (input.charCodeAt(peg_currPos) === 45) {
								s6 = peg_c60;
								peg_currPos++;
							} else {
								s6 = peg_FAILED;
								if (peg_silentFails === 0) { peg_fail(peg_c61); }
							}
							if (s6 === peg_FAILED) {
								if (input.charCodeAt(peg_currPos) === 43) {
									s6 = peg_c64;
									peg_currPos++;
								} else {
									s6 = peg_FAILED;
									if (peg_silentFails === 0) { peg_fail(peg_c65); }
								}
							}
							if (s6 === peg_FAILED) {
								s6 = null;
							}
							if (s6 !== peg_FAILED) {
								s7 = [];
								s8 = peg_parseDigit();
								if (s8 !== peg_FAILED) {
									while (s8 !== peg_FAILED) {
										s7.push(s8);
										s8 = peg_parseDigit();
									}
								} else {
									s7 = peg_FAILED;
								}
								if (s7 !== peg_FAILED) {
									s5 = [s5, s6, s7];
									s4 = s5;
								} else {
									peg_currPos = s4;
									s4 = peg_FAILED;
								}
							} else {
								peg_currPos = s4;
								s4 = peg_FAILED;
							}
						} else {
							peg_currPos = s4;
							s4 = peg_FAILED;
						}
						if (s4 === peg_FAILED) {
							s4 = null;
						}
						if (s4 !== peg_FAILED) {
							peg_savedPos = s0;
							s1 = peg_c66();
							s0 = s1;
						} else {
							peg_currPos = s0;
							s0 = peg_FAILED;
						}
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c59); }
			}

			return s0;
		}

		function peg_parseSimpleInt() {
			let s0, s1, s2, s3;

			if (input.charCodeAt(peg_currPos) === 48) {
				s0 = peg_c67;
				peg_currPos++;
			} else {
				s0 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c68); }
			}
			if (s0 === peg_FAILED) {
				s0 = peg_currPos;
				if (peg_c69.test(input.charAt(peg_currPos))) {
					s1 = input.charAt(peg_currPos);
					peg_currPos++;
				} else {
					s1 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c70); }
				}
				if (s1 !== peg_FAILED) {
					s2 = [];
					s3 = peg_parseDigit();
					while (s3 !== peg_FAILED) {
						s2.push(s3);
						s3 = peg_parseDigit();
					}
					if (s2 !== peg_FAILED) {
						s1 = [s1, s2];
						s0 = s1;
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			}

			return s0;
		}

		function peg_parseString() {
			let s0, s1, s2, s3;

			peg_silentFails++;
			s0 = peg_currPos;
			if (input.charCodeAt(peg_currPos) === 34) {
				s1 = peg_c72;
				peg_currPos++;
			} else {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c73); }
			}
			if (s1 !== peg_FAILED) {
				s2 = [];
				s3 = peg_parseCharDQ();
				while (s3 !== peg_FAILED) {
					s2.push(s3);
					s3 = peg_parseCharDQ();
				}
				if (s2 !== peg_FAILED) {
					if (input.charCodeAt(peg_currPos) === 34) {
						s3 = peg_c72;
						peg_currPos++;
					} else {
						s3 = peg_FAILED;
						if (peg_silentFails === 0) { peg_fail(peg_c73); }
					}
					if (s3 !== peg_FAILED) {
						peg_savedPos = s0;
						s1 = peg_c74(s2);
						s0 = s1;
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}
			if (s0 === peg_FAILED) {
				s0 = peg_currPos;
				if (input.charCodeAt(peg_currPos) === 39) {
					s1 = peg_c75;
					peg_currPos++;
				} else {
					s1 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c76); }
				}
				if (s1 !== peg_FAILED) {
					s2 = [];
					s3 = peg_parseCharSQ();
					while (s3 !== peg_FAILED) {
						s2.push(s3);
						s3 = peg_parseCharSQ();
					}
					if (s2 !== peg_FAILED) {
						if (input.charCodeAt(peg_currPos) === 39) {
							s3 = peg_c75;
							peg_currPos++;
						} else {
							s3 = peg_FAILED;
							if (peg_silentFails === 0) { peg_fail(peg_c76); }
						}
						if (s3 !== peg_FAILED) {
							peg_savedPos = s0;
							s1 = peg_c74(s2);
							s0 = s1;
						} else {
							peg_currPos = s0;
							s0 = peg_FAILED;
						}
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
				if (s0 === peg_FAILED) {
					s0 = peg_currPos;
					if (input.charCodeAt(peg_currPos) === 96) {
						s1 = peg_c77;
						peg_currPos++;
					} else {
						s1 = peg_FAILED;
						if (peg_silentFails === 0) { peg_fail(peg_c78); }
					}
					if (s1 !== peg_FAILED) {
						s2 = [];
						s3 = peg_parseCharBQ();
						while (s3 !== peg_FAILED) {
							s2.push(s3);
							s3 = peg_parseCharBQ();
						}
						if (s2 !== peg_FAILED) {
							if (input.charCodeAt(peg_currPos) === 96) {
								s3 = peg_c77;
								peg_currPos++;
							} else {
								s3 = peg_FAILED;
								if (peg_silentFails === 0) { peg_fail(peg_c78); }
							}
							if (s3 !== peg_FAILED) {
								peg_savedPos = s0;
								s1 = peg_c74(s2);
								s0 = s1;
							} else {
								peg_currPos = s0;
								s0 = peg_FAILED;
							}
						} else {
							peg_currPos = s0;
							s0 = peg_FAILED;
						}
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				}
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c71); }
			}

			return s0;
		}

		function peg_parseCharDQ() {
			let s0, s1;

			if (peg_c79.test(input.charAt(peg_currPos))) {
				s0 = input.charAt(peg_currPos);
				peg_currPos++;
			} else {
				s0 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c80); }
			}
			if (s0 === peg_FAILED) {
				s0 = peg_currPos;
				s1 = peg_parseEscChar();
				if (s1 !== peg_FAILED) {
					peg_savedPos = s0;
					s1 = peg_c81(s1);
				}
				s0 = s1;
			}

			return s0;
		}

		function peg_parseCharSQ() {
			let s0, s1;

			if (peg_c82.test(input.charAt(peg_currPos))) {
				s0 = input.charAt(peg_currPos);
				peg_currPos++;
			} else {
				s0 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c83); }
			}
			if (s0 === peg_FAILED) {
				s0 = peg_currPos;
				s1 = peg_parseEscChar();
				if (s1 !== peg_FAILED) {
					peg_savedPos = s0;
					s1 = peg_c81(s1);
				}
				s0 = s1;
			}

			return s0;
		}

		function peg_parseCharBQ() {
			let s0, s1;

			if (peg_c84.test(input.charAt(peg_currPos))) {
				s0 = input.charAt(peg_currPos);
				peg_currPos++;
			} else {
				s0 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c85); }
			}
			if (s0 === peg_FAILED) {
				s0 = peg_currPos;
				s1 = peg_parseEscChar();
				if (s1 !== peg_FAILED) {
					peg_savedPos = s0;
					s1 = peg_c81(s1);
				}
				s0 = s1;
			}

			return s0;
		}

		function peg_parseEscChar() {
			let s0, s1, s2, s3, s4, s5, s6, s7;

			peg_silentFails++;
			s0 = peg_currPos;
			if (input.substr(peg_currPos, 2) === peg_c87) {
				s1 = peg_c87;
				peg_currPos += 2;
			} else {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c88); }
			}
			if (s1 !== peg_FAILED) {
				peg_savedPos = s0;
				s1 = peg_c89();
			}
			s0 = s1;
			if (s0 === peg_FAILED) {
				s0 = peg_currPos;
				if (input.substr(peg_currPos, 2) === peg_c90) {
					s1 = peg_c90;
					peg_currPos += 2;
				} else {
					s1 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c91); }
				}
				if (s1 !== peg_FAILED) {
					peg_savedPos = s0;
					s1 = peg_c92();
				}
				s0 = s1;
				if (s0 === peg_FAILED) {
					s0 = peg_currPos;
					if (input.substr(peg_currPos, 2) === peg_c93) {
						s1 = peg_c93;
						peg_currPos += 2;
					} else {
						s1 = peg_FAILED;
						if (peg_silentFails === 0) { peg_fail(peg_c94); }
					}
					if (s1 !== peg_FAILED) {
						peg_savedPos = s0;
						s1 = peg_c95();
					}
					s0 = s1;
					if (s0 === peg_FAILED) {
						s0 = peg_currPos;
						if (input.substr(peg_currPos, 2) === peg_c96) {
							s1 = peg_c96;
							peg_currPos += 2;
						} else {
							s1 = peg_FAILED;
							if (peg_silentFails === 0) { peg_fail(peg_c97); }
						}
						if (s1 !== peg_FAILED) {
							peg_savedPos = s0;
							s1 = peg_c98();
						}
						s0 = s1;
						if (s0 === peg_FAILED) {
							s0 = peg_currPos;
							if (input.substr(peg_currPos, 2) === peg_c99) {
								s1 = peg_c99;
								peg_currPos += 2;
							} else {
								s1 = peg_FAILED;
								if (peg_silentFails === 0) { peg_fail(peg_c100); }
							}
							if (s1 !== peg_FAILED) {
								peg_savedPos = s0;
								s1 = peg_c101();
							}
							s0 = s1;
							if (s0 === peg_FAILED) {
								s0 = peg_currPos;
								if (input.substr(peg_currPos, 2) === peg_c102) {
									s1 = peg_c102;
									peg_currPos += 2;
								} else {
									s1 = peg_FAILED;
									if (peg_silentFails === 0) { peg_fail(peg_c103); }
								}
								if (s1 !== peg_FAILED) {
									peg_savedPos = s0;
									s1 = peg_c104();
								}
								s0 = s1;
								if (s0 === peg_FAILED) {
									s0 = peg_currPos;
									if (input.substr(peg_currPos, 2) === peg_c105) {
										s1 = peg_c105;
										peg_currPos += 2;
									} else {
										s1 = peg_FAILED;
										if (peg_silentFails === 0) { peg_fail(peg_c106); }
									}
									if (s1 !== peg_FAILED) {
										peg_savedPos = s0;
										s1 = peg_c107();
									}
									s0 = s1;
									if (s0 === peg_FAILED) {
										s0 = peg_currPos;
										if (input.substr(peg_currPos, 2) === peg_c108) {
											s1 = peg_c108;
											peg_currPos += 2;
										} else {
											s1 = peg_FAILED;
											if (peg_silentFails === 0) { peg_fail(peg_c109); }
										}
										if (s1 !== peg_FAILED) {
											peg_savedPos = s0;
											s1 = peg_c110();
										}
										s0 = s1;
										if (s0 === peg_FAILED) {
											s0 = peg_currPos;
											if (input.substr(peg_currPos, 2) === peg_c111) {
												s1 = peg_c111;
												peg_currPos += 2;
											} else {
												s1 = peg_FAILED;
												if (peg_silentFails === 0) { peg_fail(peg_c112); }
											}
											if (s1 !== peg_FAILED) {
												peg_savedPos = s0;
												s1 = peg_c113();
											}
											s0 = s1;
											if (s0 === peg_FAILED) {
												s0 = peg_currPos;
												if (input.substr(peg_currPos, 2) === peg_c114) {
													s1 = peg_c114;
													peg_currPos += 2;
												} else {
													s1 = peg_FAILED;
													if (peg_silentFails === 0) { peg_fail(peg_c115); }
												}
												if (s1 !== peg_FAILED) {
													s2 = peg_currPos;
													s3 = peg_currPos;
													s4 = peg_parseHexDig();
													if (s4 !== peg_FAILED) {
														s5 = peg_parseHexDig();
														if (s5 !== peg_FAILED) {
															s6 = peg_parseHexDig();
															if (s6 !== peg_FAILED) {
																s7 = peg_parseHexDig();
																if (s7 !== peg_FAILED) {
																	s4 = [s4, s5, s6, s7];
																	s3 = s4;
																} else {
																	peg_currPos = s3;
																	s3 = peg_FAILED;
																}
															} else {
																peg_currPos = s3;
																s3 = peg_FAILED;
															}
														} else {
															peg_currPos = s3;
															s3 = peg_FAILED;
														}
													} else {
														peg_currPos = s3;
														s3 = peg_FAILED;
													}
													if (s3 !== peg_FAILED) {
														s2 = input.substring(s2, peg_currPos);
													} else {
														s2 = s3;
													}
													if (s2 !== peg_FAILED) {
														peg_savedPos = s0;
														s1 = peg_c116(s2);
														s0 = s1;
													} else {
														peg_currPos = s0;
														s0 = peg_FAILED;
													}
												} else {
													peg_currPos = s0;
													s0 = peg_FAILED;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c86); }
			}

			return s0;
		}

		function peg_parseTxt() {
			let s0, s1, s2, s3;

			peg_silentFails++;
			s0 = peg_currPos;
			s1 = [];
			if (peg_c118.test(input.charAt(peg_currPos))) {
				s2 = input.charAt(peg_currPos);
				peg_currPos++;
			} else {
				s2 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c119); }
			}
			if (s2 === peg_FAILED) {
				s2 = peg_currPos;
				if (input.substr(peg_currPos, 2) === peg_c120) {
					s3 = peg_c120;
					peg_currPos += 2;
				} else {
					s3 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c121); }
				}
				if (s3 !== peg_FAILED) {
					peg_savedPos = s2;
					s3 = peg_c122();
				}
				s2 = s3;
				if (s2 === peg_FAILED) {
					s2 = peg_currPos;
					s3 = peg_parseEscChar();
					if (s3 !== peg_FAILED) {
						peg_savedPos = s2;
						s3 = peg_c81(s3);
					}
					s2 = s3;
				}
			}
			while (s2 !== peg_FAILED) {
				s1.push(s2);
				if (peg_c118.test(input.charAt(peg_currPos))) {
					s2 = input.charAt(peg_currPos);
					peg_currPos++;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c119); }
				}
				if (s2 === peg_FAILED) {
					s2 = peg_currPos;
					if (input.substr(peg_currPos, 2) === peg_c120) {
						s3 = peg_c120;
						peg_currPos += 2;
					} else {
						s3 = peg_FAILED;
						if (peg_silentFails === 0) { peg_fail(peg_c121); }
					}
					if (s3 !== peg_FAILED) {
						peg_savedPos = s2;
						s3 = peg_c122();
					}
					s2 = s3;
					if (s2 === peg_FAILED) {
						s2 = peg_currPos;
						s3 = peg_parseEscChar();
						if (s3 !== peg_FAILED) {
							peg_savedPos = s2;
							s3 = peg_c81(s3);
						}
						s2 = s3;
					}
				}
			}
			if (s1 !== peg_FAILED) {
				peg_savedPos = s0;
				s1 = peg_c123(s1);
			}
			s0 = s1;
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c117); }
			}

			return s0;
		}

		function peg_parseDigit() {
			let s0, s1;

			peg_silentFails++;
			if (peg_c125.test(input.charAt(peg_currPos))) {
				s0 = input.charAt(peg_currPos);
				peg_currPos++;
			} else {
				s0 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c126); }
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c124); }
			}

			return s0;
		}

		function peg_parseComma() {
			let s0, s1, s2, s3;

			s0 = peg_currPos;
			s1 = peg_parse_();
			if (s1 !== peg_FAILED) {
				if (input.charCodeAt(peg_currPos) === 44) {
					s2 = peg_c127;
					peg_currPos++;
				} else {
					s2 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c128); }
				}
				if (s2 !== peg_FAILED) {
					s3 = peg_parse_();
					if (s3 !== peg_FAILED) {
						s1 = [s1, s2, s3];
						s0 = s1;
					} else {
						peg_currPos = s0;
						s0 = peg_FAILED;
					}
				} else {
					peg_currPos = s0;
					s0 = peg_FAILED;
				}
			} else {
				peg_currPos = s0;
				s0 = peg_FAILED;
			}

			return s0;
		}

		function peg_parse_() {
			let s0, s1;

			peg_silentFails++;
			s0 = [];
			if (peg_c130.test(input.charAt(peg_currPos))) {
				s1 = input.charAt(peg_currPos);
				peg_currPos++;
			} else {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c131); }
			}
			while (s1 !== peg_FAILED) {
				s0.push(s1);
				if (peg_c130.test(input.charAt(peg_currPos))) {
					s1 = input.charAt(peg_currPos);
					peg_currPos++;
				} else {
					s1 = peg_FAILED;
					if (peg_silentFails === 0) { peg_fail(peg_c131); }
				}
			}
			peg_silentFails--;
			if (s0 === peg_FAILED) {
				s1 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c129); }
			}

			return s0;
		}

		function peg_parseHexDig() {
			let s0;

			if (peg_c132.test(input.charAt(peg_currPos))) {
				s0 = input.charAt(peg_currPos);
				peg_currPos++;
			} else {
				s0 = peg_FAILED;
				if (peg_silentFails === 0) { peg_fail(peg_c133); }
			}

			return s0;
		}

		peg_result = peg_startRuleFunction();

		if (peg_result !== peg_FAILED && peg_currPos === input.length) {
			return peg_result;
		} else {
			if (peg_result !== peg_FAILED && peg_currPos < input.length) {
				peg_fail(peg_endExpectation());
			}

			throw peg_buildStructuredError(
				peg_maxFailExpected,
				peg_maxFailPos < input.length ? input.charAt(peg_maxFailPos) : null,
				peg_maxFailPos < input.length
					? peg_computeLocation(peg_maxFailPos, peg_maxFailPos + 1)
					: peg_computeLocation(peg_maxFailPos, peg_maxFailPos)
			);
		}
	}

	return {
		SyntaxError: peg_SyntaxError,
		parse: peg_parse
	};
})();

/*******************************************************
 * format-editor.js
*******************************************************/

class FormatEditor extends HTMLElement {
	static _meta = {
		tag: 'format-editor',
		template: document.createElement('template')
	};
	#root;
	#nodes;
	#format = [];

	get format() { return this.#format; }
	get #stringifyFormat() {
		if(this.#format.length === 0) { return '""'; }
		return this.#format.map(part => {
			if(part.ty === 'txt') { return JSON.stringify(part.val) ; }
			return `{col ${JSON.stringify(part.col)}${
				part.maps.map(f => ` ➝ ${f.func}(${
					JSON.stringify(f.args).slice(1, -1)
				})`).join('')}}`;
		}).join('➕');
	}	

	constructor() {
		super();
		this.#root = this.attachShadow({mode: 'closed'});
		this.#root.appendChild(FormatEditor._meta.template.content.cloneNode(true));
		this.#nodes = {
			ip: this.#root.querySelector('textarea'),
			op: this.#root.querySelector('pre')
		};
	}
	connectedCallback() {
		this.#nodes.ip.addEventListener('keyup', () => {
			try {
				this.#format = PEG.parse(this.#nodes.ip.value);
				this.#nodes.op.classList.remove('err');
				this.#nodes.op.innerText = `Format: ${this.#stringifyFormat}`;
			} catch (err) {
				this.#format = null;
				this.#nodes.op.classList.add('err');
				this.#nodes.op.innerText = `Error: ${err.message}`;
			}
		});
		this.#nodes.ip.addEventListener('focusin', () => {
			this.#nodes.op.classList.add('show');
		});
		this.#nodes.ip.addEventListener('focusout', () => {
			this.#nodes.op.classList.remove('show');
			this.#sendChange();
		});
	}
	popupError(msg) {
		this.#nodes.ip.setCustomValidity(msg);
		this.#nodes.ip.reportValidity();
	}
	#sendChange() {
		const e = new CustomEvent('change', {
			bubbles: true,
			detail: {
				forCol: parseInt(this.dataset.col ?? '0'),
				format: this.#format
			}
		});
		this.dispatchEvent(e);
	}
	// disconnectedCallback() {}
	// adoptedCallback() {}

	// static get observedAttributes() {
	// 	return [];
	// }
	// attributeChangedCallback(attrName, oldVal, newVal) {}
}
FormatEditor._meta.template.innerHTML =
`<style>*{box-sizing:border-box;padding:0;margin:0}:host{display:block;box-shadow:var(--box-shadow)}#cntr{position:relative;display:grid}textarea{border:none;padding:var(--text-padding);background:var(--background);color:var(--color);height:3em;resize:vertical;font-family:Consolas,'Courier New',monospace}pre{display:none;position:absolute;top:calc(100% + .25em);left:.5em;max-width:calc(100% - 1em);width:calc(100% - 1em);z-index:10;white-space:pre-wrap;font-family:Consolas,'Courier New',monospace;padding:var(--text-padding);box-shadow:0 0 2px currentColor;background:var(--popup-background);color:var(--popup-color)}pre.err{background:var(--popup-err-background);box-shadow:var(--box-shadow)}pre.show{display:block}</style><div id="cntr"><textarea rows="1" placeholder="Enter format here"></textarea><pre>Format: ""</pre></div>`;
Object.freeze(FormatEditor);
customElements.define(FormatEditor._meta.tag, FormatEditor);

/*******************************************************
 * format-table.js
*******************************************************/

class FormatTable extends HTMLElement {
	static _meta = {
		tag: 'format-table',
		template: document.createElement('template')
	};
	#root; #table;
	#cols = [];
	get columns() { return this.#cols; }
	set columns(list) {
		this.#table.innerHTML = list.map((c, idx) => `<div>${c}</div><format-editor ${idx % 2 ? 'class="alt"' : ''} data-col="${idx}"></format-editor>`).join('');
		this.#table.addEventListener('change', ({detail}) => {
			const e = new CustomEvent('change', {
				bubbles: true,
				detail: detail
			});
			this.dispatchEvent(e);
		});
	}
	constructor() {
		super();
		this.#root = this.attachShadow({mode: 'closed'});
		this.#root.appendChild(FormatTable._meta.template.content.cloneNode(true));
		this.#table = this.#root.querySelector('main');
	}
	popupError(msg, colIdx) {
		this.#table.querySelector(`format-editor:nth-of-type(${colIdx + 1})`)?.popupError(msg);
	}
	// connectedCallback() {}
	// disconnectedCallback() {}
	// adoptedCallback() {}

	// static get observedAttributes() {
	// 	return [];
	// }
	// attributeChangedCallback(attrName, oldVal, newVal) {}
}
FormatTable._meta.template.innerHTML =
`<style>*{box-sizing:border-box;padding:0;margin:0}:host{display:grid;grid-template-columns:min-content 1fr;gap:.3em}header{padding:var(--text-padding);box-shadow:var(--box-shadow);background:var(--head-background);color:var(--head-color);writing-mode:vertical-lr;writing-mode:sideways-lr;text-orientation:mixed;text-align:center;font-weight:700}main{display:grid;grid-template-columns:min-content 1fr;gap:.3em}main>div{display:grid;align-items:center;justify-content:center;box-shadow:var(--box-shadow);padding:var(--text-padding);background:var(--head-background);color:var(--head-color)}main>format-editor.alt{--background:var(--alt-background)}</style><header>Define Format</header><main></main>`;
Object.freeze(FormatTable);
customElements.define(FormatTable._meta.tag, FormatTable);

/*******************************************************
 * data-preview.js
*******************************************************/

class DataPreview extends HTMLElement {
	static _meta = {
		tag: 'data-preview',
		template: document.createElement('template')
	};
	#root;
	#table;
	#title;
	#rowSize = 0;
	#rowCount = 0;

	constructor() {
		super();
		this.#root = this.attachShadow({mode: 'closed'});
		this.#root.appendChild(DataPreview._meta.template.content.cloneNode(true));
		this.#table = this.#root.querySelector('section');
		this.#title = this.#root.querySelector('header');
	}
	setData({ head = null, data = null, showColIdx = false , title = "Preview"} = {}) {
		if(!Array.isArray(head) || ! is2DArray(data, head.length)) {
			console.error('Invalid data');
			return;
		}
		this.#title.innerText = title;
		this.#rowSize = head.length;
		this.#rowCount = data.length;

		this.#table.innerHTML = [
			head.map((cell, ci) => genNode(showColIdx ? `{${ci}} ➝ ${cell}` : cell, {
				'class':'head'
			})),
			data.map((row, ri) => row.map((cell, ci) => genNode(cell, {
				'data-row': ri,
				'data-col': ci,
				'data-row-ty': ri % 2 ? 'odd' : 'even',
				'data-col-ty': ci % 2 ? 'odd' : 'even'
			})))
		].flat(2).join('');
		this.#table.style = `--row-size: ${this.#rowSize}; --row-count: ${this.#rowCount};`;
	}
	#updateCell(ri, ci, val) {
		const cell = this.#table.querySelector(`div[data-row="${ri}"][data-col="${ci}"]`);
		if(cell) {
			cell.innerText = val;
		}
	}
	updateCol(ci, values = null) {
		if(this.#rowSize <= ci || ci < 0) {
			return null;
		}
		if(values === null) {
			for(let ri = 0; ri < this.#rowCount; ri++) {
				this.#updateCell(ri, ci, '');
			}
		} else {
			for(const [ri, v] of Object.entries(values)) {
				this.#updateCell(ri, ci, v);
			}
		}
	}
	// connectedCallback() {}
	// disconnectedCallback() {}
	// adoptedCallback() {}

	// static get observedAttributes() {
	// 	return [];
	// }
	// attributeChangedCallback(attrName, oldVal, newVal) {}
}
DataPreview._meta.template.innerHTML =
`<style>*{box-sizing:border-box;padding:0;margin:0}:host{--row-size:1;--row-count:1;display:block}main{display:grid;grid-template-columns:min-content 1fr;grid-template-rows:1fr;gap:.5em}header{padding:var(--text-padding);box-shadow:var(--box-shadow);background:var(--head-background);color:var(--head-color);writing-mode:vertical-lr;writing-mode:sideways-lr;text-orientation:mixed;text-align:center;font-weight:700}section{display:grid;gap:.3em;grid-template-columns:max-content repeat(var(--row-count),min-content);grid-template-rows:repeat(var(--row-size),min-content);grid-auto-flow:column;justify-content:center;max-height:var(--max-preview-height);overflow-y:auto;overflow-x:auto}div{display:grid;align-items:center;justify-content:center;padding:var(--text-padding);box-shadow:var(--box-shadow);background:var(--background);color:var(--color)}div.head{background:var(--head-background);color:var(--head-color)}div[data-row-ty=even][data-col-ty=even],div[data-row-ty=odd][data-col-ty=odd]{background:var(--alt-background)}</style><main><header>Preview</header><section></section></main>`;
Object.freeze(DataPreview);
customElements.define(DataPreview._meta.tag, DataPreview);

/*******************************************************
 * data-mapper.js
*******************************************************/

class DataMapper extends HTMLElement {
	static _meta = {
		tag: 'data-mapper',
		template: document.createElement('template')
	};
	#root; #nodes; #ipHead; #opHead; #data;
	#rowSize; #rowCount;
	#maxPreviewLen; #previewLen;
	#allowEmpty = false; #allowConstant;
	#allowStrOutputOnly;
	#formatters = [];

	constructor() {
		super();
		this.#root = this.attachShadow({mode: 'closed'});
		this.#root.appendChild(DataMapper._meta.template.content.cloneNode(true));
		this.#nodes = {
			ip: this.#root.querySelector('data-preview'),
			format: this.#root.querySelector('format-table'),
			op: this.#root.querySelector('data-preview:nth-of-type(2)')
		};
	}
	setData({
		inputHead = [],
		data = [],
		outputHead = [],
		maxPreviewLen = 10,
		allowConstant = true,
		allowStrOutputOnly = false
	} = {}) {
		let isValid = true;
		if(Array.isArray(inputHead) && Array.isArray(outputHead)) {
			const rowSize = inputHead.length;
			if(!is2DArray(data, rowSize)) {
				isValid = false;
			}
		} else {
			isValid = false;
		}
		if(!isValid) {
			console.error('Invalid data');
			return;
		}
		this.#ipHead = inputHead;
		this.#data = data;
		this.#opHead = outputHead;
		this.#maxPreviewLen = maxPreviewLen;
		this.#rowSize = this.#ipHead.length;
		this.#rowCount = this.#data.length;

		this.#previewLen = (this.#maxPreviewLen < this.#rowCount) ? this.#maxPreviewLen : this.#rowCount;
		this.#allowConstant = allowConstant;

		this.#nodes.ip.setData({
			title: "Input Preview",
			showColIdx: true,
			head: this.#ipHead,
			data: this.#data.slice(0, this.#previewLen)
		});
		this.#nodes.format.columns = this.#opHead;
		this.#nodes.op.setData({
			title: "Output Preview",
			head: this.#opHead,
			data: ((row, col) => {
				const ret = [];
				let onerow = [];
				for(let i=0; i<col; i++) {
					onerow.push('');
					this.#formatters.push([]);
				}
				for(let j=0; j<row; j++) {
					ret.push([...onerow]);
				}
				return ret;
			})(this.#previewLen, this.#opHead.length)
		});
		this.#nodes.format.addEventListener('change', ({
			detail: {forCol, format}
		}) => {
			if(format === null) {
				this.#formatters[forCol] = undefined;
			} else {
				if(format.length === 0 && !this.#allowEmpty) {
					this.#nodes.format.popupError('Formatter is required. Use [[empty]] for empty string', forCol);
					this.#formatters[forCol] = undefined;
					return;
				}
				if(format.length === 1 && format[0].ty === 'txt' && !this.#allowConstant) {
					this.#nodes.format.popupError('Only constant value is not allowed', forCol);
					this.#formatters[forCol] = undefined;
					return;
				}
				const ipHeadLen = this.#ipHead.length;
				for(let item of format) {
					if(item.ty === 'exp') {
						if(typeof item.col !== 'number') {
							const idx = this.#ipHead.indexOf(item.col);
							if(idx === -1) {
								this.#nodes.format.popupError(`Unknown column {${item.col}}`, forCol);
								this.#formatters[forCol] = undefined;
								return;
							} else {
								item.col = idx;
							}
						} else {
							if(ipHeadLen <= item.col || item.col < 0) {
								this.#nodes.format.popupError(`Unknown column {${item.col}}`, forCol);
									this.#formatters[forCol] = undefined;
									return;
							}
						}
						for(const {func} of item.maps) {
							if(!FuncList.includes(func)) {
								this.#nodes.format.popupError(`Unknown mapper used: '${func}'`, forCol);
								this.#formatters[forCol] = undefined;
								return;
							}
						}
					}
				}

				this.#formatters[forCol] = format;
				this.#nodes.op.updateCol(forCol, this.#mapOpPreviewCol(format, this.#previewLen));
			}
		})
	}
	#mapOpPreviewCol(format, max = null) {
		max ??= this.#rowCount;
		const colValues = [];
		for(let ri = 0; ri < max; ri++) {
			colValues.push(this.#formatData(this.#data[ri], format));
		}
		return colValues;
	}
	#formatData(row, format) {
		const retVal = [];
		for(const f of format) {
			switch (f.ty) {
				case 'txt':
					retVal.push(f.val);
					break;
				case 'exp':
					let val = row[f.col];
					for(const m of f.maps) {
						val = FormatFuncs[m.func](val, ...m.args);
					}
					retVal.push(val);
					break;
				default: break;
			}
		}
		if(!this.#allowStrOutputOnly && retVal.length === 1) {
			return retVal[0];
		}
		return retVal.join('');
	}
	async getFormattedData() {
		for(let col = 0; col < this.#opHead.length; col++) {
			const formatter = this.#formatters[col];
			if(typeof formatter === 'undefined') {
				this.#nodes.format.popupError('Please define a correct formatter for this column', col);
				return null;
			}
			if(formatter.length === 0 && !this.#allowEmpty) {
				this.#nodes.format.popupError('Formatter is required. Use [[empty]] for empty string', col);
				return null;
			}
			if(formatter.length === 1 && formatter[0].ty === 'txt' && !this.#allowConstant) {
				this.#nodes.format.popupError('Only constant value is not allowed', col);
				return null;
			}
		}
		const opRowSize = this.#opHead.length;
		const table = [];
		for(const row of this.#data) {
			const formmattedRow = [];
			for(let ci = 0; ci < opRowSize; ci++) {
				let data = this.#formatData(row, this.#formatters[ci]);
				data = data.trim().toLowerCase() === '[[empty]]' ? '' : data;
				formmattedRow.push(data);
			}
			table.push(formmattedRow);
		}
		return {
			head: this.#opHead,
			data: table
		};
	}
	// connectedCallback() {}
	// disconnectedCallback() {}
	// adoptedCallback() {}

	// static get observedAttributes() {
	// 	return [];
	// }
	// attributeChangedCallback(attrName, oldVal, newVal) {}
}
DataMapper._meta.template.innerHTML =
`<style>*{box-sizing:border-box;padding:0;margin:0}:host{display:grid;gap:.5em;--text-padding:0.5em 0.75em;--box-shadow:0 0 2px currentColor;--background:#121212;--alt-background:#263238;--color:white;--popup-background:#0d47a1;--popup-err-background:#d50000;--popup-color:white;--head-background:#0d47a1;--head-color:white;--max-preview-height:32vh}</style><data-preview></data-preview><format-table></format-table><data-preview></data-preview>`;
Object.freeze(DataMapper);
customElements.define(DataMapper._meta.tag, DataMapper);